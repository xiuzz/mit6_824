# 课程前导
这节课主要说明了下本课程使用go语言作为实现工具，实际上现代的大部分分布式系统都是go语言写的，以太坊，ipfs等等，go的原生支持高并发(goroutine)，和完善的rpc库，让其天生就是运用于这个场景。

# 线程(Threads)

线程的概念在这里就不赘述了。这节课对于线程主要回答了这几个问题：

## 1.为什么要使用多线程？

很明显在分布式系统中，甚至是一个庞大的单主机服务器中对于繁忙的业务处理，或者是i/o等待这种情况，使用多线程来支持并发处理，比一个线程处理多业务上，要容易实现的多，（程序员不需要过多的优化代码算法，就可用利用多核多线程的硬件优势，来完成任务，大大减少人力成本）。因此多线程的优势主要体现在下面三点：

### 1.1 I/O并发（I/O concullency）

学过os的都知道，cpu的处理效率是远远高于
I/O设备，在串行运行的程序里面，cpu只能等待当前I/O完成后，才能接着运行下一段代码，而多线程中，我们能让所有的I/O请求并发进行。

### 1.2 并行处理(Parallelism)

正如前面所说的，对于多核cpu，并行处理，要比串行处理要容易解决大业务能力水平高的多，程序员不需要过多的优化代码算法，就可用利用多核多线程的硬件优势，来完成任务，大大减少人力成本。

### 1.3 方便(Convenience)

调用线程处理是非常方便的，比如在go里面的goroutine，你只需要创建一个goroutine对象就可用了，就可以轻松并发运行代码，而且线程比进程(process)简单的特性在于，进程之间是相互隔离的，每一个进程拥有自己的地址空间(address space),和自己的任务(task),进程间没办法直接共享资源（a进程给b进程资源，实际上是做了一个a进程资源的备份给b进程,这里不是os，就不详细展开了），而线程是进程里面实际运行任务的实体(至少在类unix系统中是这样),他们可以直接共享地址空间的资源，随便进行传递(因为就在同一个地址空间中)。

# 2. 提问环节
线程这里还有一部分内容，是他回答学生的提问，比如进程和线程的区别，当线程切换时候上下文是否切换等等,这些问题太偏向os了，那个老师也没怎么回答到具体细节，相应感兴趣的可以查下相关资料，学习计算机感觉对底层部分保留对应的抽象还是比较重要的吧（毕竟也只是做了层接口, 我挑几个我觉得比较重要的说说：

### 2.1 事件驱动程序（异步编程，event-driven or async）

这个学过js的就应该很清楚吧，nodejs用的就是典型的异步编程，还有就是windwos很多程序也是用这个做的。什么是异步编程呢？他是一个另外的方法解决运行大规模业务繁忙的手段，做法是在一个单线程的程序中，他设置了一个事件循环，每次在这个循环中切换，一旦事件来临，完成这个事件，否则循环到下一个等待事件，这种做法是耗费程序员的精力的，如果想构建一个异步系统，你需要始终考虑有多少个循环，边界在哪里，如何在每一个each中处理好事件来临。当时如果真的做出来一个异步系统，那么他是小而五脏俱全的精美程序的，只需要单核单线程就可以完成多核处理所做到的事情，而且随着你的线程开的越多，比如开了1000000个线程，那么线程之间的切换代价是昂贵的，而异步编程就能避免这个问题。(这么一看nodejs的设计理念相当不错啊，js那么薄弱的性能，都能充当后端，处理百万级别并发)。

### 2.2 线程锁相关的操作

这里不讲锁操作系统是怎么得知的，而是编程语言怎么提供锁，和程序员怎么使用锁，比如go语言里面锁只是一个对象，你可以设置很多锁，而go是不知道你锁的东西是什么，锁的本质只是程序获得这个变量才能进行接下来的操作，执行完后再释放就可以了。